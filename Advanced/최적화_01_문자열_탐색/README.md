# 문자열 탐색

## ▶ Hasing (해싱)
● 하나의 디렉토리에 존재 가능한 **파일의 수에 제한이 없음**  
  → 디렉토리 경로를 따라가기, 디렉토리 내에 존재하는 파일들 나열하기, 특정 파일의 존재 유무를 판별하기 등의 검색 기반 작업들은 성능 저하의 원인이 됨.  

● 해싱은 **특정 항목 검색**시, 탐색 키에 대한 **산술적 연산으로 key가 있는 위치를 계싼**하여 바로 검색하는 방법. **→ O(1)**  

● 직접 번지 테이블(배열) 사용  
  → **전체 key들의 집합이 작은 경우에 효율적**  
  → key가 테이블의 특정 위치에 저장됨  
  → **테이블 배열의 크기 = 전체 key들의 집합의 크기**  
  
### Hash table (해시 테이블)★★  
● 전체 key들의 집합이 클 때, 현실적인 컴퓨터 메모리 공간에서 테이블 생성 불가능  

● 실제 저장되는 key들의 집합이 전체 key들의 집합에 비해 상대적으로 작아서 많은 메모리가 누수됨.  
  
● 모든 가능한 key들의 집합(U)에 비해 실제 사용되는 key들의 집합(K)가 작을 경우 〓＞ **Hash table 메모리 공간 < 직접 번지 테이블 메모리 공간**  
  → 저장 공간을 K로 줄임, key값 자료의 저장할 위치를 계산하는 **해시 함수** 사용  
  → key값 자료를 해시 함수의 위치에 저장  
  
 ### Hash function (해시 함수)
 ● 모든 key들의 집합(U)를 해시 테이블(T)의 위치에 대응시킴  
  → 테이블의 index 범위 줄여줌  
  → hash_function(key)는 key의 **해시 값(주소)**라고 함  

※ 복수의 key가 **동일한 위치**가 되는 상황을 **Hash collision(충돌)**이라함  

### Collision (충돌)
● 서로 다른 key값을 해시 함수에 적용했을 때, **반환된 해시 주소가 동일한 경우**  

● 해시 함수가 아무리 해시 주소를 공평하게 분배해도 **해시 테이블에 저장되는 key에 해당하는 자료의 수가 증가**하면 충돌 불가피  

● 이러한 충돌의 해결 방안으로는 **Chaining(체이닝), Open addressing(개방 주소법)**등이 존재함.  

#### Chaning (체이닝)★
● 해시 테이블의 구조를 변경하여, **각 bucket(버킷)에 하나 이상의 key값을 가지는 자료가 저장** 될 수 있도록 하는 방법  
  → 하나의 bucket에 여러 개의 key값을 저장하도록 하기 위해 **Linked List 활용**  

![image](https://user-images.githubusercontent.com/33312417/236147145-3b944308-7d32-46a1-9464-a7cd6ce1871d.png)



#### Open addressing (개방 주소법)★
● 해시 함수로 구한 주소에 빈 공간이 없어 충돌이 발생하면, **그 다음 공간에 빈 공간 여부를 조사**  
  → 빈 공간이 있으면, 탐색 key에 대한 항목 저장  
  → 빈 공간이 없으면, 공간이 나올 때까지 탐색 반복  

![image](https://user-images.githubusercontent.com/33312417/236147048-1d1a1a68-95c2-4fbb-8d8a-380b3a7e7e7e.png)



 
## ▶ 문자열 매칭★★
● 많은 응용 분야에서 중요한 요소  
  1. Infomation Retrieval(정보 검색): 키워드 기반의 웹페이지 검색  
  2. Communication Systemp(통신 시스템): 텍스트 메시지, E-mail 전송, E-book 다운로드 등  
  3. Programming System(프로그래밍 시스템): 컴파일러, 인터프리터 등  
  4. Genomics(유전체학): DNA를 문자열 형태(A, C, T, G)로 표현 후 처리  
  
## Pattern matching(패턴 매칭)★★★
● 텍스트 문자열에 **패턴 문자열의 포함 여부**를 탐색하는 것  
  → 브루트포스, 카프-라빈, KMP 알고리즘, 보이어-무어 알고리즘 등  

### Brute-Force (브루트 포스) 〓 O(N * M)
● **텍스트 문자열을 처음부터 끝까지 차례대로 순회**하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작 

● 비교할 패턴과 원본 문자열 모두 **첫 문자열부터 시작**  

● 최악의 경우, **텍스트의 모든 위치에서 패턴을 비교**  

### Karp-Rabin (카프-라빈 알고리즘) 〓 O(선형?) ~ O(N * M)
● **해시 함수** 사용  

● **패턴의 해시 값**과 텍스트 내의 패턴의 길이 만큼의 **문자열에 대한 해시 값을 비교**  

● 패턴 길이 만큼의 문자열을 한 글자씩 읽어서 해시 값을 계산하지 않고, 새로 추가되는 문자와 그전에 읽었던 값을 이용하여 해시 값 계산(**이전 해시 값을 이용해서 다음 해시 값을 구함**).  

● 최악의 경우, O(N *M)이지만 평균적으로는 **선형에 가까운 빠른 속도를 가지는 알고리즘**  

※ 주의 사항 ※  
1. 처음 해시 값을 구할 때는 **찾고자 하는 문자열에서 패턴 길이 만큼 읽음**  

2. 패턴의 길이가 커지면 길이를 일정 자릿수로 맞추기 위해 **모듈러(Mod) 연산 진행**  

3. 해시 값이 일치하면 **실제 문자열이 일치하는지도 검사**  

### Knuth-Morris-Pratt (KMP 알고리즘) 〓 O(N + M)
● 알고리즘을 제안한 사람들의 이름 첫글자를 따옴  

● 불일치가 발생한 텍스트 문자열의 앞부분에 어떤 문자가 있는지 미리 알고 있으므로, **불일치가 발생한 앞부분에 대하여 다시 비교하지 않고 매칭 수행##  

● 불일치가 발생하면, **다음 비교할 위치를 미리 계산**해서, 불필요한 시작 최소화  
  → 패턴의 모든 위치마다 불일치가 발생하면, 이동할 위치를 계산해서 저장  
  → 패턴의 길이 만큼 별도의 **next[pattern_length] List** 필요  
  
● **next[]**  
  → 불일치 발생 시 돌아갈 곳을 저장하는 List.  
  → 최대 패턴 길이만큼의 **접두어, 접미어**가 필요함.  
  → 문자열의 모든 부분 문자열들은 모든 접미어들의 모든 접두어들의 집합   
  




### () 〓 O()
### () 〓 O()
 
 
 
