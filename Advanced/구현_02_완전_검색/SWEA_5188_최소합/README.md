# 분석

## Fail → RE(Runtime Error)
● BFS()로 간단하게 풀릴 줄 알았으나, 6연속 Test case(8/10)에서 RE를 맞았다.  
문제가 복잡하지 않아서 MLE(Memory Limit Exceeded)는 생각조차 안했었고, 남은 가능성은 TLE인데  애초에 주어진 N의 크기가 13밖에 되지않아 모든 경로를 검색한들 절대 걸리지 않을것 같았다.  
BOJ에서는 이런 상황에서 RE가 걸릴리가 없을것같아 SWEA의 채점 서버에 차이인가 싶어서 검색을 해본 결과 대개 다음과 같은 경우라한다.  
```  
→ 배열에 할당된 크기를 넘어서 접근 했을 때  
→ 전역 배열의 크기가 메모리 제한을 초과할 때  
→ 지역 배열의 크기가 스택 크기 제한을 넘어갈 때  
→ 라이브러리에서 예외를 발생시켰을 때  
→ ZeroDivisionError: division by zero.  
→ RecursionError: maximum recursion depth exceeded.  
→ 이미 해제된 메모리를 또 참조할 때  
→ 프포그램(main 함수)이 0이 아닌 수를 반환했을 때  
```
● 우선 내 코드에서 RE가 생길만한 이유를 못 찾던 중, 답답하여 구글링 해보니 모두 DFS()로 푼 것을 보고 의아했다.  
실제로 나처럼 BFS()를 사용한 사람이 없길래 나는 오기가 생겨 BFS()로 풀어봤다.  
이하 내용은 그동안 내 코드를 분석하면서 왜 BFS()가 아닌 DFS()를 쓰는지 대해 깨달은 것들.   

### 코드 자가 분석
1. BFS()로는 문제에서 최종 요구하는 최솟값을 갱신해 나가기 위해 **중간중간** 최솟값을 갱신하는데, 이 과정에서 현재 누적값이 Solution인지를 **확신하지 못하니** 갱신될 때 마다 **return으로 중단을 못한다**   

결국 최종 경로가 가까워질 때까지 결과론적으로 쓸데없는 경로까지 돌게되어 Queue의 반복이 잦다.  

2. 1번을 깨닫고 나서 임시 변수로 Queue의 반복이 얼마나 잦은지 확인했더니, 자체 반례에서 **136135**번 찍히는 것을보고 메모리 관련 런타임 에러라는것을 바로 납득했음..  

3. 1번을 방지하고자 Queue에서 Data를 꺼낸이후 '현재까지 누접합 >= 결괏값'이면 continue로 넘어가게도 해놨었으나, 결국 Pruning 과정에서도 1번의 한계점인 **현재 누적값을 확신하지 못하기** 때문에 의미가 없었고 비교하는 이 횟수 마저도 자체 반례에서 **48603**번 돌아버림..  

4. 즉, 위의 항목들로 인해 시간 복잡도는 제한에 걸리지 않을지라도 Queue의 **메모리에서 문제**가 발생해 런타임 에러가 났다는걸 스스로 확인 할 수 있었음.  

## PASS
● 보통 이러한 문제에선 주로 BFS()를 쓰는편인데, 해당 문제처럼 문제 상황에 따라 DFS()로 자유롭게 변환해야한다는 것을 깨달음.  

● 실패했던 코드들을 DFS()로 바꾸니 자가 분석에서 나온 횟수가 10591, 5124로 확연히 줄어들어 PASS가 된 걸 확인할 수 있었음.  


### Test용 자체 반례
```
1
10
0 2 2 2 2 2 2 2 2 2
1 1 1 2 2 2 2 2 2 2
2 2 1 1 2 2 2 2 2 2
2 2 2 1 2 2 2 2 2 2
2 2 2 1 1 1 2 2 2 2
2 2 2 2 2 1 1 2 2 2
2 2 2 2 2 2 1 2 2 2
2 2 2 2 2 2 1 1 2 2
2 2 2 2 2 2 2 1 1 1
2 2 2 2 2 2 2 2 2 0
〓> 17
```
