## ▶ Graph(그래프)
● 객체(사물 또는 추상적 개념)들과 객체들 사이의 **연결 관계 표현**  
● **Vertex(정점)** 들의 집합과 정점을 연결하는 **Edge(간선)** 들의 집합으로 구성된 자료구조  
  → 그래프의 최대 간선 수 = `(V * V-1) / 2`  
  
● 선형 자료구조, 트리 자료구조로 표현하기 어려운 `N:N` 관계를 가지는 원소들을 표현하기에 용이  

### 종류 및 개념
1. Undirected Graph(무향 그래프)  
  → 서로 대칭적인 관계를 연결해서 나타낸 그래프  

2. Directed Graph(유향 그래프)  
  → 간선을 화살표로 표현하고, 방향성의 개념 포함  
  → 서로 대칭적이지 않은 관계 표현  
  
3. Weighted Graph(가중치 그래프)  
  → 주로 정점간 이동하는데 드는 비용을 간선에 부여햔 그래프  

4. 완전 그래프  
  → 모든 정점들이 서로 인접해 있는 그래프  
  → Adjacency(인접): 두 개의 정점에 간선이 존재(연결됨)할 경우 서로 인접해 있다고 함  
  → 일부의 정점이나 간선을 제외한 그래프 = **부분 그래프**  
  
5. Directed Acyclic Graph (DAG, 사이클이 없는유향 그래프)  
  → Cycle(사이클): 시작한 정점에서 끝나는 경로  
  
#### 컴퓨터에서의 그래프 표현
● 간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정  

#### **Adjacent matrix (인접 행렬)**  
● 특징  
  → V x V 크기의 2차원 리스트를 이용해서 간선 정보 저장    
  → 두 정점을 연결하는 간선의 유무를 행렬 형태로 표현  
  → In 무향 그래프: `i번째 행의 합 = i번째 열의 합 = Vi의 차수`  
  → In 유향 그래프: `행 i의 합 = Vi의 진출 차수 / 열 i의 합 = Vi의 진입 차수`  
  
● 단점  
→ 정점의 개수 N이 커지면 **인접 행렬에 필요한 메모리 크기는 n^2에 비례** 해서 커짐  
→ 어떤 정점의 인접 정점을 **찾을 때마다, 빈번한 탐색**  

● 개선  
→ 그래프에 포함된 간선의 수가 많지 않을 경우 **메모리 사용을 줄이기 위해** 간선들의 정보를 나열해서 저장  
→ 간선의 시작 정점과 끝 정점의 정보 저장  
→ 간선 List에서 **어떤 정점의 인접 정점 = 일치하는 시작 정점**  


#### **Adjacent List (인접 리스트)**  
  → **Linked List**  
  → 각 정점마다 인접 정점으로 나가는 간선의 정보 저장  
  → **인접 행렬의 단점을 보완**할 수 있음    


## ▶ 그래프 탐색
● 비선형구조인 그래프로 표현된 모든 자료(정점)를 완전 탐색하는 기법  

1. **Depth First Search (DFS)**  
  → Recursion(재귀) 기반  
  
2. **Breadth First Search (BFS)**  


## ▶ 서로소 or 상호배타 집합
● 서로 중복 포함된 원소가 없는 집합들, **교집합이 없음**  

● 집합에 속한 하나의 특정 원소를 통해 각 집합들을 구분  
  → 특정원소 = Representative (대표자)  

● 상호배타 집합을 표현하는 방법: Linked list, Tree  

● **상호배타 집합 연산**  
  → Make-Set(x): 원소 x만으로 구성된 집합을 생성  
  → Find-Set(x): 임의의 원소 x가 속한 집합을 알아내기 위해 사용, 집합의 대표자를 알기 위한 연산  
  → Union(x, y): 원소 x가 속한 집합과 원소 y가 속한 집합을 하나의 집합으로 합침  
  
#### 1. Linked list로 표현   
● 특징  
  → 같은 집합의 원소들은 하나의 Linked list로 관리  
  → Linked list의 **첫 번째 원소를 집합의 대표자로 선택**  
  → 각 원소는 **집합의 대표원소를 가리키는 링크**를 가짐  
  → 두 집합(Linked list)간을 Union() 할 경우, **크기가 작은 집합을 큰 집합의 뒤에 연결**  
   
#### 2. Tree로 표현 (최단경로 트리)
● 특징  
  → **Linked list보다 효율적인 표현** 방법  
  → 하나의 집합(a disjoint set)을 하나의 트리로 표현  
  → Child node가 Parent node를 가리키며, Root node는 자기 자신을 가리킴(= 대표자)  
  → Union() 할 경우, **대표자 중 하나가 다른 대표자를 Parent로 가리키게 하는 한 번의 연산**만 필요(Linked list에 비해 간단함)   

● 상호배타 집합을 트리로 표현하기 위해 **List 사용**  
  → 각 원소의 부모에 대한 정보 저장 형태  
  → 원소의 개수만큼 List가 필요함  
  → **자기 자신을 부모로 가리킴 == 집합의 대표자**  

  `원소 | 0 1 2 3 4 5`  
  `부모 | 0 1 2 2 2 4`    
  `       ━━━━━> Representative(0, 1, 2)`  

● 문제점  
  → 집합간 Union() 과정에서 **편향된 트리 구조 생성**  
  → 이때, Find()를 수행하면 **간선의 수만큼 재귀호출 필요** => 모든 원소들이 Root를 Parent로 가리키게 하면 개선 가능  

● 연산의 효율을 높이는 방법  
1. Rank를 이용한 Union  
  → 각 node는 자신을 root로 하는 Sub-tree의 높이를 Rank(랭크)라는 이름으로 저장  
  → 두 집합을 합칠 때, Rank가 낮은 집합을 Rank가 높은 집합에 붙임  
  → 트리의 높이가 다를 경우= Rank값 변경이 필요 없음  
  → 트리의 **높이가 같을** 경우= **Rank값 변경**, 아무 Tree나 선택해서 다른 Tree의 Sub-tree로 포함 후 Rank값 갱신     

2. Path compression (경로 압축)  
  → Find-Set()을 행하는 과정에서 만나는 모든 node들이 직접 Root를 가리키도록 Parent 정보를 변경   
  
### 상호배타 집합의 연산들  
● **효율성을 고려**해서 작성된 알고리즘  

● 구현이 간단, 동작 속도가 빠르기 때문에 **그래프 영역에서 많이 사용**되고 **다른 알고리즘의 일부로 활용됨**  
  → 그래프의 연결성 확인  
  → **KRUSKAL Minimum Spanning Tree(MST) 알고리즘**  

● 각 집합에 속한 원소의 수 관리  
  → Size() 구현 시 용이함  
  → 가장 큰 집합 추적 or 특정 시점에서 집합의 노드 개수가 몇개 이상인지 확인 등  
  

1. Make_Set(x): 유일한 멤버 X를 포함하는 새로운 집합을 생성하는 연산  
`# p[x]: 노드 x의 부모 저장`  
`# rank[x]: Root node가 x인 tree의 rank값 저장`  
  
`def Make_Set(x):`  
`    p[x] = x  # 자기 자신`  
`    rank[x] = 0`  

2. Find_Set(x): x를 포함하는 집합을 찾는 연산  
`def Find_Set(x):`  
`    if x != p[x]:  # x가 root가 아닌 경우`  
`        p[x] = Find_Set(p[x])  # 경로 압축`  
`    return p[x]`  
→ 대표자를 찾은 경우: (호출했던 곳으로 되돌아 오면서) 특정 Node에서 Root까지의 **경로에 존재하는 Node가 Root를 Parent로 가리키도록 갱신**  

3. Union(x, y): x와 y를 포함하는 두 집합을 통합하는 연산  
`def Union(x, y):`  
`     # 두 집합의 대표자인 Root 찾기`  
`    Link(Find_Set(x), Find_Set(y))`  

`def Link(x, y):`  
`    if rank[x] > rank[y]:`  
`        p[y] = x  # y의 parent를 x로 설정`  
  
`    elif rank[x] == rank[y]:`  
`        p[x] = y  # x의 부모를 y로 설정`  
`        rank[y] += 1  # Root인 y의 Rank값 증가`  
  
`    else:  # rank[x] < rank[y]`  
`        p[x] = y  # x의 부모를 y로 설정`  

