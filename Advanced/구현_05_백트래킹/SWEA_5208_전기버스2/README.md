# 분석

### WA_1.py
● 직관적 코딩.  
● 이동하는 상황별로 자원을 갱신하며 재귀호출, Pruning X  
  → TLE(5/10) = 최대 N이 100개인데, 주어진 충전량은 최소 1이상임.  
즉, 어떤 경우든 **다음 역까지는 이동이 보장**되므로 최악의 경우 **N - 2번의 재귀 호출**이 발생하기 때문으로 추정.  

● 재귀 호출 중, `현재 cnt >= res` 지점에서 return 시키는 **Pruning 추가.**
→ WA(5/10)

### WA_2.py
● visited를 활용한 DFS.  
● WA_1.py와 동일하게 TLE.  

● Pruning을 해도 TLE → WA로 같은 결과.  
  → 재귀 횟수를 찍어본 결과, TC 2~3 기준 WA_1, WA_2 모두 반복 횟수가 같았음.  
  → (Non Pruning= 32, 22 / Pruning= 20, 18)  
  → 테스트 결과로 미루어봤을 때, **로직 자체의 결함**이 있다고 판단함.  

## PASS.py
#### 문제 재해석..  
● 기존 TLE & WA 에서는 "다음 정류장 이동 시 거리 1당 Energy 1 감소 → 다음 정류장에서 충전시 **현재 Energy + 충전량**을 누적."하며 계산 했음.     
하지만, 전기버스 자체의 용량은 상관없고, 단지 문제에서 주어진 **"충전지마다 최대로 운행할 수 있는 정류장 수가 정해져 있다."** 라는 문장으로 인해  
**"특정 정류장 도착 시 전기버스의 최대 이동 거리 = 정류장에서 주어진 교체용 충전지량"** 으로 계속 바뀐다는 점을 파악했음.  

● 비슷한 문제를 BOJ에서 풀어봤던 습관적 해석이었는지 나는 당연하게도 충전량을 누적해 나가서 틀렸던 것임.  

● 문제를 다시 꼼꼼히 보니 딱히 전기 버스의 충전량의 대한 언급이나, 충전의 영향으로 다른 조건이 변한다는 언급이 없었기 때문에 초기 해석을 잘못했다고 판단됨.  

● 이후 수정하여 PASS 됐고, Pruning 유무로 인한 큰 차이는 없었는데 TLE 여부로 나뉜다는게 좀 신기했음.  
→ (Non Pruning= 22, 18 / Pruning= 20, 18), 아마 N이 작아서 그런것 같다.  
