## ▶ 그래프에서 최소 비용 문제
### Minimum Spanning Tree (MST, 최소 신장 트리)
● 가중치 그래프에서 **모든 정점들을 연결하는 간선들의 가중치의 합이 최소**가 되는 트리를 찾는 문제  
※ 가중치 그래프에서 신장 트리를 구성하는 **간선들의 가중치의 합이 최소인 신장 트리**  
  → 최소 신장 트리를 찾는 알고리즘 = **프림, 크루스칼 알고리즘**  

● Spanning Tree (신장 트리)  
  → N개의 정점을 포함하는 무향 그래프에서 **N개의 정점과 (N-1)개의 간선**으로 구성된 트리  
  → 그래프에 존재하는 신장 트리의 수 = 정점의 개수와 간선의 수에 **비례하여 증가**  
  
### Shortest Path (최단 경로)
● **시작 정점에서 목표 정점까지 가는 간선의 가중치의 합이 최소**가 되는 경로를 찾는 문제  

  
## ▶ (프림 알고리즘)
● 한 정점에 연결된 간선들 중 하나씩 선택하면서 최소 신장 트리를 만들어 가는 방식  
  1. 임의의 정점을 하나 선택해서 시작  
  2. 선택한 정점들과 인접하는 정점들 중, 최소 비용의 간선이 존재하는 정점 선택  
  3. 모든 정점이 선택될 때 까지 2번 과정을 반복  
  └→ 정점의 수 N, 시작 정점을 제외한 (N-1)개의 정점 선택  
  └→ (N-1)개의 간선 선택됨 / 선택된 정점들과 간선들은 하나의 Tree 구성  
  
### 알고리즘의 동작
● 두 종류의 **상호 배타 집합들(2 Disjoint-sets)** 정보 필요함  
  1. Tree vertices (트리 정점들) = 최소 신장 트리를 만들기 위해 선택된 정점들의 집합    
  2. Non-tree vertices (비트리 정점들) = 선택되지 않은 정점들의 집합   

`def MST_PRIM(Graph, start):  # 그래프, 시작 정점`  
`    key = [INF] * N  # 1. 가중치를 무한대로 초기화`  
`    parent = [None] * N  # 2. 트리에서 연결될 부모 정점 초기화`  
`    visited = [False] * N  # 3. 방문 여부 초기화`  
`    key[start] = 0  # 4. 시작 정점의 가중치를 0으로 설정`  
  
`    for _ in range(N):  # 5. 정점의 개수만큼 반복`  
`        minIndex = -1`  
`        minValue = INF`  

`        # 6. 방문 안한 정점중 최소 가중치 정점 찾기`  
`        for k in range(N):`  
`            if not visited[k] and key[k] < minValue:`  
`            minValue = key[k]`  
`            minIndex = k`  
    
`        # 7. 최소 가중치 정점 방문 처리`      
`        visited[minIndex] = True`  

`        # 8. 선택 정점의 인접한 정점`  
`        for v, val in Graph[minIndex]:`  
`            if not visited[v] and val < key[v]:`  
`                key[v] = val  # 9. 가중치 갱신`  
`                parent[v] = minIndex  # 10. 트리에서 연결될 부모 정점`  







``  
``  
``  
