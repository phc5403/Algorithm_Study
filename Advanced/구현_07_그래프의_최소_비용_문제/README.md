## ▶ 그래프에서 최소 비용 문제
### Minimum Spanning Tree (MST, 최소 신장 트리)
● 가중치 그래프에서 **모든 정점들을 연결하는 간선들의 가중치의 합이 최소**가 되는 트리를 찾는 문제  
※ 가중치 그래프에서 신장 트리를 구성하는 **간선들의 가중치의 합이 최소인 신장 트리**  
  → 최소 신장 트리를 찾는 알고리즘 = **프림, 크루스칼 알고리즘**  

● Spanning Tree (신장 트리)  
  → N개의 정점을 포함하는 무향 그래프에서 **N개의 정점과 (N-1)개의 간선**으로 구성된 트리  
  → 그래프에 존재하는 신장 트리의 수 = 정점의 개수와 간선의 수에 **비례하여 증가**  
  
### Shortest Path (최단 경로)
● **시작 정점에서 목표 정점까지 가는 간선의 가중치의 합이 최소**가 되는 경로를 찾는 문제    

● 간선의 가중치가 있는 유향 그래프에서, 두 정점 사이의 경로들 중 **간선의 가중치의 합이 최소인 경로**  

● 종류  
1. 단일 시작점 최단 경로  
  → 출발점에서 다른 모든 정점들에 이르는 최단 경로를 구하는 문제   **※ Dijkstra(다익스트라)= 음의 가중치를 허용하지 않음**  
**※ Bellman-Ford(벨만-포드)= 음의 가중치 허용, 가중치 합이 음수인 사이클은 허용하지 않음**    
  
2. 모든 쌍 최단 경로 문제  
  → 모든 정점 쌍 간의 최단 경로를 구하는 문제  
**※ Floyd-Warshall (플로이드-워셜)= DP 관련**  
  
## ▶ Prim Algorithm (프림 알고리즘)
● 한 정점에 연결된 간선들 중 하나씩 선택하면서 최소 신장 트리를 만들어 가는 방식  
  1. 임의의 정점을 하나 선택해서 시작  
  2. 선택한 정점들과 인접하는 정점들 중, 최소 비용의 간선이 존재하는 정점 선택  
  3. 모든 정점이 선택될 때 까지 2번 과정을 반복  
  └→ 정점의 수 N, 시작 정점을 제외한 (N-1)개의 정점 선택  
  └→ (N-1)개의 간선 선택됨 / 선택된 정점들과 간선들은 하나의 Tree 구성  
  
### 알고리즘의 동작 
● 두 종류의 **상호 배타 집합들(2 Disjoint-sets)** 정보 필요함  
  1. Tree vertices (트리 정점들) = 최소 신장 트리를 만들기 위해 선택된 정점들의 집합    
  2. Non-tree vertices (비트리 정점들) = 선택되지 않은 정점들의 집합   

`def MST_PRIM(Graph, start):  # 그래프, 시작 정점`  
`    # 0. key[]= parent[]에 저장된 간선의 가중치 저장 / parent[]= 정점이 트리에 연결될 때 사용된 간선 정보 저장`  
`    key = [INF] * N  # 1. 가중치를 무한대로 초기화`  
`    parent = [None] * N  # 2. 트리에서 연결될 부모 정점 초기화`  
`    visited = [False] * N  # 3. 방문 여부 초기화`  
`    key[start] = 0  # 4. 시작 정점의 가중치를 0으로 설정`  
  
`    for _ in range(N):  # 5. 정점의 개수만큼 반복`  
`        minIndex = -1`  
`        minValue = INF`  

`        # 6. 방문 안한 정점중 최소 가중치 정점 찾기`  
`        for k in range(N):`  
`            if not visited[k] and key[k] < minValue:`  
`            minValue = key[k]`  
`            minIndex = k`  
    
`        # 7. 최소 가중치 정점 방문 처리`      
`        visited[minIndex] = True`  

`        # 8. 선택 정점의 인접한 정점`  
`        for v, val in Graph[minIndex]:`  
`            if not visited[v] and val < key[v]:  # 9. 비트리 정점중 key값보다 더 작은 가중치로 트리에 연결 가능한 경우`  
`                key[v] = val  # 10. 가중치 갱신`  
`                parent[v] = minIndex  # 11. 트리에서 연결될 부모 정점`  


## ▶ Kruskal Algorithm (크루스칼 알고리즘)
● Cycle이 생기지 않도록 최소 가중치 간선을 하나씩 선택해서 최소 신장 트리를 찾는 알고리즘  
  → N개의 정점을 포함하는 그래프에서 (N-1)개의 간선을 선택하는 방식  
  → Prim은 하나의 트리를 확장시켜가는 방식이지만, Kruskal은 간선을 선택해 나가는 과정에 여러 개의 트리들이 존재함  
  
● 특징  
1. 초기 상태= **N개의 정점들이 각각 하나의 트리**가 됨  
  → 하나의 정점을 포함하는 N개의 상호 배타 집합 존재    
  → 간선을 선택하면 간선의 두 정점이 속한 트리가 연결되고, **하나의 집합으로 합쳐짐**  

2. 선택한 간선의 두 정점이 이미 연결된 트리에 속한 정점들일 경우 Cycle이 생김  
  → **두 정점에 대해 같은 집합의 원소 여부 검사**  
  
3. 간선 선택 과정에서 생성되는 트리를 관리하기 위해 **상호 배타 집합 사용**  
  → 트리에 속한 노드들은 **자신을 Root로 하는 서브트리의 높이를 Rank로 관리**  
  
4. 선택한 간선으로 두 개의 트리가 합쳐질 때, **각 트리에 해당하는 상호 배타 집합을 Union 연산으로 합침**  
  → Rank값이 작은 트리를 Rank값이 큰 트리의 서브트리로 포함시킬 경우, **트리에 포함된 노드들의 Rank값 수정 불필요**  

### 알고리즘의 동작 과정  
1. 최초, 모든 간선을 가중치에 따라 **오름차순**으로 정렬  

2. **가중치가 가장 낮은 간선부터 선택**하면서 트리를 확장  
  → 이 때, Cycle이 존재하면 다음으로 가중치가 낮은 간선 선택  
  
3. (N-1)개의 간선이 선택될 때까지 2번 과정을 반복  

`def MST_KRUSKAL(Graph):`
`    # 간선을 선택해 나가면서 생성되는 트리들을 상호배타 집합으로 관리함`  
`    mst = []  # 공집합, 최소 신장 트리를 구성하는 간선들의 집합`  
  
`    # 하나의 정정만 포함하는 상호배타 집합을 정점의 수 만큼 생성`    
`    for k in range(N):`  
`        Make_Set(k)`  

`    # 가중치 기준으로 정렬`  
`    Graph.sort(key = lambda x: x[2])`  
  
`    mst_cost = 0  # MST 가중치`  
  
`    while len(mst) < N-1:`  
`        u, v, val = Graph.pop(0)  # 최소 가중치 간선 가져오기`  
`        # 정점 u, v가 같은 집합의 원소인지 확인(Cycle 방지)`    
`        if Find_Set(u) != Find_Set(v):`  
`            Union(u, v)`  
`            mst.append((u, v))  # 트리에 (u, v) 추가`  
`            mst_cost += val`  




