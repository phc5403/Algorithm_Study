# SW 문제 해결

## 프로그래밍 하기 위한 제약 조건과 요구 사항
● Programming language의 특성  
● Program이 동작할 H/W와 OS에 관한 지식  
● Library들의 유의 사항들  
● Program이 사용할 수 있는 최대 Memory  
● 사용자 대응 시간 제한  
● 재사용성이 높은 간결한 코드  
→ 서로 다른 환경에 속한 프로그래머들의 능력(역량) 평가 어려운 이유들.  

## SW 문제 해결 역량이란?
● 프로그램 작성을 위한 많은 **제약 조건들과 요구사항들을 이해**하고 **최선의 방법을 찾아내는 능력**   
● 언어, 라이브러리, 자료구조, 알고리즘에 대한 지식을 **적재적소에 연결하여 큰 그림을 만드는 능력**  
● 문제 해결 역량은 **추상적인 기술**
  → 명확히 정의된 실체가 없음  
  → 알고리즘들을 암기하고 문제를 풀어본다고 향상되지 않음  
● 문제 해결 역량 향상을 위해선 **훈련 필요**  

## 문제 해결 능력을 향상시키는 훈련
● 새로운 언어, 프레임워크, 개발 방법론들의 **조합 방법을 배워야 함**  
● **프로그래밍 경험을 통해서 나아질 것이라는 기대**를 하지 않아야 함  
  → 경험에서 문제 해결 능력 개발이 가능한 상황이 항상 주어지지 않음.  
  → 문제 해결 능력 개발이 가능한 상황에서 자기 계발하기 어려움.  
●  **인위적 상황을 만들어 훈련**해야 함  
  → **정제된 추상적인 문제를 제시**하고 해결하면서 문제 해결 능력을 향상시킬 수 있는 **훈련 필요**  
  
## 문제 해결 과정 단계(PS) ☆★☆★
1. 문제를 읽고 이해하기  
2. 문제를 익숙한 용어로 재정의하기  
3. 어떻게 해결할지 계획 세우기  
4. 계획 검증하기  
5. 프로그램으로 구현하기  
6. 풀이를 돌아보고, 개선할 방법 찾기 

## 문제 해결 전략 
● **직관**과 **체계적인** 접근  

● 체계적인 접근을 위한 질문들  
→ 비슷한 문제를 풀어본 적이 있던가?
→ 단순한 방법에서 시작할 수 있을까?
→ 문제를 단순화, 그림으로, 수식으로 표현할 수 있을까? 
→ 문제를 분해 할 수 있을까?
→ 뒤에서부터 생각해서 문제를 풀 수 있을까?
→ 특정 형태의 답만을 고려할 수 있을까?

▶▷▶▷ 글로 써놓고 읽어보면, 당연한 얘기이면서 실제 내가 PS 문제를 풀 때에도 대부분 맞게 적용하는 부분이다.  
하지만 지금의 역량으로는 각 단계별로 올바른 솔루션, 판단이 잘 되지 않는 실정임.  

## ☆★☆★ 알고리즘 복잡도 ☆★☆★
● Algorithm : 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법.  
컴퓨터가 어떤 일을 수행하기 위한 단계적 방법(어떠한 문제를 해결하기 위한 절차)  

● 알고리즘의 효율  
Complexity(효율성) = 복잡도 = 높을수록 효율성 저하  
알고리즘 설계 → 실행에 필요한 자원 분석 → 효율성 제시  

1. 공간적 효율성 : 얼마나 많은 메모리 **공간**을 요하는가?  
2. 시간적 효율성 : 얼마나 많은 **시간**을 요하는가? 

● 시간적 복잡도에 관한 분석  
1. 하드웨어 환경(부동소수 처리 프로세서 존재 유무, 나눗셈 가속 기능 유무, 입출력 장비의 성능 & 공유 여부 등)에 따라 처리시간 달라짐  
2. SW 환경(언어, OS, 컴파일러 등의 종류)에 따라 처리시간 달라짐  
→ 이러한 환경적 차이로 인해 **분석 어려움**  

● 시간 및 공간 복잡도의 점근적 표기  
1. 입력 크기에 대한 함수(다항식)로 표기  
2. 단순한 함수로 표현하기 위해 **Asymptotic Notation**(점근적 표기) 사용  
〓> `O(Big-Oh)` / `Ω(Big-Omega)` / `θ(Theta)` 표기가 존재함.  

### ▶ O(Big-Oh) 표기: 점근적 상한
![image](https://user-images.githubusercontent.com/33312417/232460805-2d0958fb-adb6-4679-8628-bdd199570c9a.png)

![image](https://user-images.githubusercontent.com/33312417/232460970-522ca826-7355-4820-a33e-0ce38f3f188f.png)


### ▶ Ω(Big-Omega) 표기: 점근적 하한
![image](https://user-images.githubusercontent.com/33312417/232461226-d8b3dafc-af41-4ff3-9352-d3fb7ec25948.png)

![image](https://user-images.githubusercontent.com/33312417/232461483-815ca9b9-cfc2-4425-b0c0-81a5cf509630.png)


### ▶ θ(Theta) 표기: 점근적 상한과 하한이 동일
![image](https://user-images.githubusercontent.com/33312417/232461788-484aa06f-3808-4f4f-8d82-95cf834c508c.png)


### 자주 사용하는 O-표기
![image](https://user-images.githubusercontent.com/33312417/232461981-daef0eed-7db5-4501-a77c-9d5a9cbd50de.png)



## 비트 연산
![image](https://user-images.githubusercontent.com/33312417/232463655-1d5d5916-bae8-4d2e-a383-c9baf4751967.png)


● 프로그램에서 비트 연산 적용시 **연산 속도를 향상시키거나 메모리 절약 가능**  
EX) Even, Odd 판별 시 `N & 1`과 같이 비트단위 AND(&) 연산으로 마지막 비트값이 1 or 0인지를 판단함  

![image](https://user-images.githubusercontent.com/33312417/232464320-d1fd62b0-4fbd-4654-979a-30c39ebc34d6.png)


● 비트 연산의 예시_1  
`# 8비트의 문자형 변수에 저장된 비트값들을 출력하는 함수`    
`def BitPrint(i)`  
`    for j in range(7, -1, -1):`  
`        print('1' if (i & (1 << j)) else '0', end=""`  
`        #print(f'{((i >> j) & 1)}', end="")`  
  
`for i in range(-5, 6):`  
`    print(f'{i} = ', end="")  # 십진수 출력`  
`    BitPrint(i)  # 이진수 출력`  
`    print()`  
  
● 비트 연산의 예시_2  
→ 4 byte 크기의 int형 변수에 저장된 값들을 한 byte씩 읽어서 bit 형태로 출력하는 예제  
`a = 0x10  # 1 byte 정수형 변수에 16진수 표기법으로 값을 저장`  
`x = 0x01020304  # 4 byte 정수형 변수에 16진수 표기법으로 값을 저장`  
  
`print(f'{a} = ', end="")`  
`BitPrint(a)`  
`print()`  
`print(f'{x} = ', end="")`  
  
`for i in range(0, 25, 8):`  
`    BitPrint(x >> i)`  
`    print(end=" )`  
  
## Endianness (엔디안)  
● 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법(HW 아키텍처마다 다름).  
● 속도 향상을 위해 byte 단위와 워드 단위를 변환하여 연산할 때 **올바로 이해하지 않으면 오류를 발생시킬 수 있음**  

1. Big-endian  
  → 보통 큰 단위가 앞에 나옴, 네트워크에서 사용하는 방식  
 
2. Little-endian  
  → 작은 단위가 앞에 나옴, 대다수 데스크탑 컴퓨터에서 사용하는 방식  

● 2, 4 byte 16진수 표현이 실제 메모리에 하위 byte부터 저장되는 예  
종류        | 0x1234의 표현(2 byte)    | 0x12345678의 표현(4 byte)  
빅 엔디안   | 12 34                    | 12 34 56 78   
리틀 엔디안 | 34 12                    | 78 56 34 12  

4:40 ~> 

