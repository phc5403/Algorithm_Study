# SW 문제 해결

## 프로그래밍 하기 위한 제약 조건과 요구 사항
● Programming language의 특성  
● Program이 동작할 H/W와 OS에 관한 지식  
● Library들의 유의 사항들  
● Program이 사용할 수 있는 최대 Memory  
● 사용자 대응 시간 제한  
● 재사용성이 높은 간결한 코드  
→ 서로 다른 환경에 속한 프로그래머들의 능력(역량) 평가 어려운 이유들.  

## SW 문제 해결 역량이란?
● 프로그램 작성을 위한 많은 **제약 조건들과 요구사항들을 이해**하고 **최선의 방법을 찾아내는 능력**   
● 언어, 라이브러리, 자료구조, 알고리즘에 대한 지식을 **적재적소에 연결하여 큰 그림을 만드는 능력**  
● 문제 해결 역량은 **추상적인 기술**
  → 명확히 정의된 실체가 없음  
  → 알고리즘들을 암기하고 문제를 풀어본다고 향상되지 않음  
● 문제 해결 역량 향상을 위해선 **훈련 필요**  

## 문제 해결 능력을 향상시키는 훈련
● 새로운 언어, 프레임워크, 개발 방법론들의 **조합 방법을 배워야 함**  
● **프로그래밍 경험을 통해서 나아질 것이라는 기대**를 하지 않아야 함  
  → 경험에서 문제 해결 능력 개발이 가능한 상황이 항상 주어지지 않음.  
  → 문제 해결 능력 개발이 가능한 상황에서 자기 계발하기 어려움.  
●  **인위적 상황을 만들어 훈련**해야 함  
  → **정제된 추상적인 문제를 제시**하고 해결하면서 문제 해결 능력을 향상시킬 수 있는 **훈련 필요**  
  
## 문제 해결 과정 단계(PS) ☆★☆★
1. 문제를 읽고 이해하기  
2. 문제를 익숙한 용어로 재정의하기  
3. 어떻게 해결할지 계획 세우기  
4. 계획 검증하기  
5. 프로그램으로 구현하기  
6. 풀이를 돌아보고, 개선할 방법 찾기 

## 문제 해결 전략 
● **직관**과 **체계적인** 접근  

● 체계적인 접근을 위한 질문들  
→ 비슷한 문제를 풀어본 적이 있던가?
→ 단순한 방법에서 시작할 수 있을까?
→ 문제를 단순화, 그림으로, 수식으로 표현할 수 있을까? 
→ 문제를 분해 할 수 있을까?
→ 뒤에서부터 생각해서 문제를 풀 수 있을까?
→ 특정 형태의 답만을 고려할 수 있을까?

▶▷▶▷ 글로 써놓고 읽어보면, 당연한 얘기이면서 실제 내가 PS 문제를 풀 때에도 대부분 맞게 적용하는 부분이다.  
하지만 지금의 역량으로는 각 단계별로 올바른 솔루션, 판단이 잘 되지 않는 실정임.  

## ☆★☆★ 알고리즘 복잡도 ☆★☆★
● Algorithm : 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법.  
컴퓨터가 어떤 일을 수행하기 위한 단계적 방법(어떠한 문제를 해결하기 위한 절차)  

● 알고리즘의 효율  
Complexity(효율성) = 복잡도 = 높을수록 효율성 저하  
알고리즘 설계 → 실행에 필요한 자원 분석 → 효율성 제시  

1. 공간적 효율성 : 얼마나 많은 메모리 **공간**을 요하는가?  
2. 시간적 효율성 : 얼마나 많은 **시간**을 요하는가? 

● 시간적 복잡도에 관한 분석  
1. 하드웨어 환경(부동소수 처리 프로세서 존재 유무, 나눗셈 가속 기능 유무, 입출력 장비의 성능 & 공유 여부 등)에 따라 처리시간 달라짐  
2. SW 환경(언어, OS, 컴파일러 등의 종류)에 따라 처리시간 달라짐  
→ 이러한 환경적 차이로 인해 **분석 어려움**  

● 시간 및 공간 복잡도의 점근적 표기  
1. 입력 크기에 대한 함수(다항식)로 표기  
2. 단순한 함수로 표현하기 위해 **Asymptotic Notation**(점근적 표기) 사용  
〓> `O(Big-Oh)` / `Ω(Big-Omega)` / `θ(Theta)` 표기가 존재함.  

### ▶ O(Big-Oh) 표기: 점근적 상한
![image](https://user-images.githubusercontent.com/33312417/232460805-2d0958fb-adb6-4679-8628-bdd199570c9a.png)

![image](https://user-images.githubusercontent.com/33312417/232460970-522ca826-7355-4820-a33e-0ce38f3f188f.png)


### ▶ Ω(Big-Omega) 표기: 점근적 하한
![image](https://user-images.githubusercontent.com/33312417/232461226-d8b3dafc-af41-4ff3-9352-d3fb7ec25948.png)

![image](https://user-images.githubusercontent.com/33312417/232461483-815ca9b9-cfc2-4425-b0c0-81a5cf509630.png)


### ▶ θ(Theta) 표기: 점근적 상한과 하한이 동일
![image](https://user-images.githubusercontent.com/33312417/232461788-484aa06f-3808-4f4f-8d82-95cf834c508c.png)


### 자주 사용하는 O-표기
![image](https://user-images.githubusercontent.com/33312417/232461981-daef0eed-7db5-4501-a77c-9d5a9cbd50de.png)



## 비트 연산
![image](https://user-images.githubusercontent.com/33312417/232463655-1d5d5916-bae8-4d2e-a383-c9baf4751967.png)


● 프로그램에서 비트 연산 적용시 **연산 속도를 향상시키거나 메모리 절약 가능**  
EX) Even, Odd 판별 시 `N & 1`과 같이 비트단위 AND(&) 연산으로 마지막 비트값이 1 or 0인지를 판단함  

![image](https://user-images.githubusercontent.com/33312417/232464320-d1fd62b0-4fbd-4654-979a-30c39ebc34d6.png)


● 비트 연산의 예시_1  
`# 8비트의 문자형 변수에 저장된 비트값들을 출력하는 함수`    
`def BitPrint(i)`  
`    for j in range(7, -1, -1):`  
`        print('1' if (i & (1 << j)) else '0', end=""`  
`        #print(f'{((i >> j) & 1)}', end="")`  
  
`for i in range(-5, 6):`  
`    print(f'{i} = ', end="")  # 십진수 출력`  
`    BitPrint(i)  # 이진수 출력`  
`    print()`  
  
● 비트 연산의 예시_2  
→ 4 byte 크기의 int형 변수에 저장된 값들을 한 byte씩 읽어서 bit 형태로 출력하는 예제  
`a = 0x10  # 1 byte 정수형 변수에 16진수 표기법으로 값을 저장`  
`x = 0x01020304  # 4 byte 정수형 변수에 16진수 표기법으로 값을 저장`  
  
`print(f'{a} = ', end="")`  
`BitPrint(a)`  
`print()`  
`print(f'{x} = ', end="")`  
  
`for i in range(0, 25, 8):`  
`    BitPrint(x >> i)`  
`    print(end=" )`  
  
## Endianness (엔디안)  
● 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법(HW 아키텍처마다 다름).  
● 속도 향상을 위해 byte 단위와 워드 단위를 변환하여 연산할 때 **올바로 이해하지 않으면 오류를 발생시킬 수 있음**  

1. Big-endian  
  → 보통 큰 단위가 앞에 나옴, 네트워크에서 사용하는 방식  
 
2. Little-endian  
  → 작은 단위가 앞에 나옴, 대다수 데스크탑 컴퓨터에서 사용하는 방식  

● 2, 4 byte 16진수 표현이 실제 메모리에 하위 byte부터 저장되는 예  
종류        | 0x1234의 표현(2 byte)    | 0x12345678의 표현(4 byte)  
빅 엔디안   | 12 34                    | 12 34 56 78   
리틀 엔디안 | 34 12                    | 78 56 34 12  

● 비트 연산의 예시_3: 자신의 PC가 어떤 엔디안 방식인지 확인하는 코드  
`N = 0x00111111`  
`if N & 0x11:`  
`    print("Little Endian")`  
`else: print("Big Endian")`  

→ 4byte 16진수 표현에서 큰 단위의 값 '00'이 메모리의 시작주소에 해당하는 byte에 저장된다면 Big, 아니면 Litte: 난 리틀  

● 비트 연산의 예시_4  
→ 비트 연산자 `^`(배타적 논리합)를 2번 변환하면 처음 값을 복구  
  
`A = 0x86`  
`key = 0xAA`  
`print(f"A => {BitPrint(A)}")`  
`  `  
`# A의 값을 key값과 ^(XOR)해서 변경된 값을 다시 A에 저장`  
`print("A ^= key ==> ", end='')`  
`A ^= key`  
`BitPrint(A)`  
`print()`  
`  `  
`A를 다시 key값과 ^(XOR)하면 원래의 값으로 돌아옴`  
`print("A ^= key ==> ", end='')`  
`A ^= key`  
`BitPrint(A)`  
    

## Binary (진수)
● 주로 2진수, 8진수, 10진수, 16진수를 사용함  
● 어떤 수 N을 원하는 X진수로 계속 나누었을 때, 마지막에 남는 수는 X진수의 최상위 비트 **MSB(Most significant bit)** 라고 함  

#### 컴퓨터에서의 음의 정수 표현 방법  
● 1의 보수: 부호와 절댓값으로 표현된 값을 부호 비트(제일 왼쪽 최상위비트)를 제외 한 나머지 비트들을 0 ↔ 1 변환  

※ EX)  
`-6 : 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 = 부호와 절댓값 표현`  `-6 : 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 = 1의 보수 표현`  
`     └→ 최상위 비트(1=음수, 0=양수)  `   

● 2의 보수: 1의 보수방법으로 표현된 값의 **최하위 비트**에 1을 더함  

※ EX)  
`-6 : 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 = 1의 보수 표현`  
`-6 : 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 = 2의 보수 표현`  
`                  자리 올림 발생 ←┘ └→ 최하위 비트에 1을 더함`  

### 10진수 실수 → 2진수로 변환 ★★
● 10진수 소숫점을 2진수로 변환하는 과정  
  1. 소숫점에 2를 곱한다.  
  2. 2를 곱한 값 > 1.0: 2진수 1을 붙임, 소숫점의 정수부분을 지우고 다시 1번 반복  
  3. 2를 곱한 값 < 1.0: 2진수 0을 붙임, 1번 반복  
  4. 2를 곱한 값 == 1.0: 2진수 1을 붙임, **반복 종료**  
  
**※ 위 과정에서 무리수가 되어 무한 루트가 될 수 있으니, 적절한 사용법으로 반복을 끊어야함 !!**  

## Float (실수)  
● 실수는 영어로 'Real number'라고 하는데, 컴퓨터는 실수를 **부동 소수점**으로 표현한다.  부동 소수점이 영어로 'Floating point'라서 실수형을 표현하는 타입을 'Float'이라고 함.  

● **Floating-point**(부동 소수점 표기법)  
  → 소수점의 위치를 고정시켜 표현하는 방식  
  → `1001.0011 => 1.0010011 x 2^3`  
     └→ 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현   
     
● 컴퓨터에서의 실수 저장 형식  
부호 / 가수부 / 지수부로 구분하여 저장.  

1. 단정도 실수(32 비트)  
 → 부호 1비트 | 지수 8비트 | 가수 23비트  
 
2. 배정도 실수(64 비트)  
  → 부호 1비트 | 지수 11비트 | 가수 52비트  
  
Mantissa(가수부): 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것   
Exponent(지수부): 실제 소수점의 위치를 지수 승으로 표현한 것  

※ Java, C에서는 단정도 실수를 4 Byte 크기의 flaot, 배정도 실수를 8 Byte 크기의 double 타입으로 제공하지만, Python에서의 실수표현은 단정도 실수 없이 배정도 실수만 8 Byte 크기의 float 타입으로 제공한다.  

#### 단정도 실수    
● 단정도 실수의 가수 부분, 지수 부분, 지수부 Excess(익세스) 표현법   
→ 5차시 영상 2:15 ~   

● 컴퓨터는 실수를 근사적으로 표현함.  
● 이진법으로 표현 할 수 없는 형태의 실수는 정확한 값이 아니라 근삿값으로 저장 → 이로 인해 생기는 작은 오차가 계산 과정에서 다른 결과를 가져옴   

● 실수 자료형의 유효 자릿수  
단정도 실수: 32 비트 실수형 유효 자릿수(십진수) = 6 (7자리 이상 저장시 오차 발생할 수 있음)  
배정도 실수: 64 비트 실수형 유효 자릿수(십진수) = 15  


