## ▶ Greedy Algorithm(탐욕|그리디 알고리즘)
● **최적화 문제**를 해결하는 알고리즘  
  → 탐욕 알고리즘은 **최적해**를 구하는 데 사용되는 근시안적인 방법  
  
● **최적화 문제** : 최적(최대 혹은 최소)값을 구하는 문제  
  → 해당 문제에 여러 해가 있을 수 있음  
  → 일반적으로 직관적으로 떠오르는 생각을 검증 없이 바로 구현할 경우 Greedy한 접근이 됨  
  
● 일반적인 흐름  
여러 경우 중 하나 선택 → 선택 시 마다 최적이라고 생각되는 것을 선택 → **최종적인 해답에 도달**  

1. 한 번 선택된 것은 번복하지 않음: 대부분의 탐욕 알고리즘들은 **단순하며, 제한적인 문제들에 적용**  
2. **각 선택의 시점**에서 이루어지는 **결정은 지연적으로 최적임**: 선택들을 계속 수집하여 최정적 해답을 만들었다고 하여 **최적이라는 보장은 없음**  

### 세부적인 흐름
1. 해 선택  
  → 현재 상태에서 부분 문제의 최적해를 구한 뒤, **Solution Set(부분 해 집합)**에 추가  
  → 하나의 선택이 이루어지면 새로운 부분 문제 발생  
  
2. 실행 가능성 검사 실시  
  → 새로운 부분 해 집합의 **실행 가능 여부 확인**  
  → 문제의 **제약 조건 위반을 검사**  

3. 해 검사  
→ 새로운 부분 해 집합이 문제의 해가 되는지 확인  
→ 전체 문제의 해가 완성되지 않았다면, **1번으로 돌아가서 반복**  

## ▶ 배낭 문제 ★★★★
### 1. 0-1 Knapsack
● 배낭에 물건을 **통째로 담아야** 하는 문제  
● 물건을 **쪼갤 수 없는 경우**  

#### 완전 검색 적용
1. 완전 검색으로 물건들의 집합 S에 대한 **모든 Subset을 구함**  
2. Subset의 **총 무게가 배낭 무게 W를 초과하는 집합들을 버리고**, 나머지 집합에서 총 값(Value)이 가장 큰 집합 선택  

3. 물건의 개수가 증가하면 **시간 복잡도가 지수적으로 증가**: `원소가 n개인 집합의 부분 집합의 개수 = 2^n`  

### 2. Fractional Knapsack  
● 물건을 **부분적으로 담는** 것이 허용되는 문제  
● 물건을 **쪼갤 수 있는 경우**  

## ▶ 회의실 배정 문제 ★★
● 최대의 활동 선택 문제: 회의 시간이 Non-overlapping(서로 겹치지 않는) **최대 개수의 활동들의 집합**을 구하는 문제

● locally optimal choice (탐욕적 선택)
  1. 종료 시간이 빠른 순서로 활동들 정령  
    → 탐색 편의를 위해 임의로 <b>a0(주어진 가장 빠른 시작시간보다 작은 종료값), an(주어진 가장 느린 종료시간보다 큰 시작값)</b> 를 설정할 수 있다.    

  2. 첫 번째 활동(a1)을 선택하고 해집합에 포함  

  3. 선택한 활동(a1)의 종료 시간보다 빠른 시작 시간을 가지는 활동을 모두 제거  

  4. 남은 활동들에 대해 위 과정을 반복  

● 재귀를 사용한 풀이 과정  
`# A: 정렬된 활동(회의)들의 집합`  
`# S: 선택된 활동(회의)들의 집합`  
`# si: 시작 시간, fi: 종료 시간 (1 <= i <= n)`  
  
`Recursive_Selection(i, j):`  
`    m = i + 1`  
  
`    while m <= j and sm < fi:`  
`        m += 1`  
  
`    if m <= j: return {am} ∪ Recursive_Selection(m,j)`  
`    else: return {}  # 공집합`  

● 탐욕 알고리즘이 최적해를 구한다는 것에 대한 증명  
1. **Greedy choice property** (탐욕적 선택 속성)  
  → 탐욕적 선택은 최적해로 갈 수 있음: 항상 안전하다는 것을 보여야 함  

※ 즉, **종료 시간이 가장 빠른 활동**을 **선택**하는 것은 **항상 안전**  

2. **Optimal substructure property** (최적 부분 구조)  
  → 최적화 문제를 정형화: 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남음  
  → **원 문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해**임을 증명 

## ▶ Greedy VS DP
● 공통점: Optimal substructure property  

![image](https://user-images.githubusercontent.com/33312417/233563756-99fa9878-a6f5-4b43-afd6-453acabd4d01.png)


## 대표적인 Greedy 기반의 알고리즘들
![image](https://user-images.githubusercontent.com/33312417/233565080-bd462bf5-f985-4bf6-a653-9ba8873d92f7.png)



