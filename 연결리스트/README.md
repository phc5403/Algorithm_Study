# Linked List

## ▶ LIST (리스트)
● **순서를 가진** 데이터의 묶음 = 같은 데이터의 중복 저장 가능.  
● **Sequence 자료형** = Indexing, Slicing, Operator, Method 사용 가능.  
● 크기 제한, 타입 제한 없음.  
● 데이터의 묶음이라는 개념이 타언어의 배열과 흡사함.
  → 배열은 초기에 크기 지정, 변경 불가.  
  → List는 동적 배열의 개념으로, 크기 변경 가능.  
  → 또한, 배열은 선언된 한가지 타입만 저장이 가능하지만 List는 다양한 데이터 타입 저장 가능.  
  → 타언어에서 배열로 구현한 순차 리스트 = Python의 List.  
  → 순차 리스트 : 배열을 기반으로 구현된 리스트.  
  → 연결 리스트 : 메모리의 동적할당을 기반으로 구현된 리스트.  

● 순차 List의 특징  
→ **동적 배열**로 작성된 순차 리스트.  
→ 자료의 삽입/삭제시 **내부적으로는 원소들을 이동** 하는 작업이 필요함.  
→ 때문에 원소의 개수가 많고, 삽입/삭제 연산이 빈번하면 **작업에 소요되는 시간이 크게 증가함.**  

### List의 복사★☆★☆  
● **얕은** 복사, **깊은** 복사가 존재 함.  
● 보통 얕은 복사는 대상과의 **참조한 곳은 동일**하기 때문에 독립적이지 않다.  
● 깊은 복사는 복사 대상과 독립된 객체가 된다.  

● **여러가지 복사 방법들**(밑의 항목일 수록 실행시간이 긺), 방법들 마다 속도 차이가 30배 정도 날 수도 있다.    
  1. `new_list = old_list`   
  2. `new_list = old_list[:]`  
  3. `new_list = []`  
     `new_list.extend(old_list)`  
  4. `new_list = list(old_list)`  
  5. `import copy`  
     `new_list = copy.copy(old_list)`  
  6. `new_list = [k for k in old_list]`  
  7. `import copy`  
     `new_list = copy.deepcopy(old_list)`   
     → **가장 느림, 가장 메모리 소모 큼(하지만 완전한 깊은 복사)**  
  
  ※ 영상에서는 각 방법들마다 얕은, 깊은 복사의 부연 설명까지 되어있으나, 설명이 모호함.
  
  ※ 예를들면, 2번의 경우 깊은 복사라고 해놓았지만 실제 `[:]` 방법은 얕은과 깊은의 혼종 복사이기 때문임. 실제로 내부 원소가 같아지고 참조하는 id()도 달라 깊은 복사 같지만 만약 **List안에 내부 List**가 존재할 경우 그 내부 list는 같은 값을 참조하기 때문에 얕은 복사가 되버림.  
  
  ※ [복사 관련 참고 링크] https://blockdmask.tistory.com/576  
  
## ▶ Linked List (연결 리스트)☆★☆★  
● List의 단점을 보완한 자료 구조.  
● 자료의 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않고, **개별적으로 위치하고 있는 원소의 주소를 연결하여 하나의 전체적인 자료구조**를 이룸.  
● Link를 통해 원소에 접근하므로, 순차 리스트에서 **물리적인 순서를 맞추기 위한 작업이 필요하지 않음.**  
● 자료구조의 크기를 동적으로 조정할 수 있어, **메모리의 효율적인 사용이 가능.**  
● 탐색을 할 때는 **순차 탐색** 활용.  

### 주요 함수★  
`addtoFirst()` : 앞쪽에 원소를 추가  
`addtoLast()`  : 뒤쪽에 원소를 추가  
`add()`        : 특정 위치에 원소를 추가  
`delete()`     : 특정 위치의 원소를 삭제  
`get()`        : 특정 위치의 원소를 Return  
  
### 구성 요소  
● Node : 연결 리스트에서 하나의 원소에 필요한 데이터를 갖고 있는 자료 단위.  
  → 데이터 필드 = 원소의 값을 저장하는 자료구조  
  → 링크 필드 = 다음 노드의 주소를 저장하는 자료구조  
  
● Head : 리스트의 처음 노드를 가리키는 reference(참조)  
  → 링크 필드만 가지고 있어, Head 자체에는 데이터 없음.   
  
### 1. 단순 연결 리스트  
● Node가 하나의 Link field에 의해 다음 Node와 연결되는 구조  

●  Head가 가장 앞의 Node를 가리키고, 각 Node의 Link field가 연속적으로 다음 Node를 가리킴  

● 마지막 Node는 None을 가리킴  

### 2. 이중 연결 리스트  
● 양방향으로 순회할 수 있도록 Node를 연결한 리스트

● 두 개의 Link field와 한 개의 Data field로 구성  

● prev / data / next

## ▶ Linked List의 활용: 1. 정렬☆★☆★  

### 1. Insertion sort (삽입 정렬) = O(n^2)  
● 자료 배열의 모든 원소들을 앞에서부터 차례대로 이미 정렬된 부분과 비교하여, 자신의 위치를 찾아냄으로써 정렬을 완성.  

● 정렬 과정    
  1. 정렬할 자료를 두 개의 부분 집합 S와 U로 분리  
    S : 정렬된 앞부분의 원소들  
    U : 아직 정렬되지 않은 나머지 원소들  
  
  2. U의 원소를 하나씩 꺼내서 S의 **마지막 원소부터 비교**하면서 위치를 찾아 삽입.  
  
  3. 위의 2번을 반복하면서 S의 원소는 늘려가고, U의 원소는 감소시킴(각 부분집합의 원소를 매번 비교해야함).    
  
  4. 최종적으로 U가 공집합이 되면 완료.  
  
### 2. Merge sort (병합 정렬) = O(n log n)      
● Divide and Conquer 기반  
  → **자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬**하여 최종 결과를 얻어냄.  
  → Top-Down 방식이라고도 함.  
  
● 정렬 과정  
  1. Divide : 전체 자료 집합에 대하여, 최소 크기의 부분집합이 될 때까지 분할 작업을 반복함  
  
  2. Merge : 2개의 부분집합을 정렬하면서 하나의 집합으로 병합  
● 알고리즘(분할 과정)  
```
def merge_sort(m):
  if len(m) <= 1:
    return m
  
  # Divide
  mid = len(m) // 2
  left = m[:mid]
  right = m[mid:]
  
  # 1개의 원소가 남을 때 까지 재귀 호출
  left = merge_sort(left)
  right = merge_sort(right)
  
  # Conquer (분할된 리스트들 병합)
  return merge(left, right)
```
  
● 알고리즘(병합 과정)  
```
def merge(left, right):
  result = []
  
  # 양쪽 리스트에 원소가 남아있는 동안 반복
  while len(left) > 0 and len(right) > 0:
    if left[0] <= right[0]:
      result.append(left.pop(0))
    else:
      result.append(right.pop(0))
      
  # 왼쪽 리스트에 원소가 남아있는 경우
  if len(left) > 0:
    result.extend(left)
  
  # 오른쪽 리스트에 원소가 남아있는 경우
  if len(right) > 0:
    result.extend(right)

  return result
```

※ 구현할 때 배열 or 연결리스트를 사용할 수 있음.  
배열은 분리 & 병합하는 과정에서 자료의 비교와 이동 연산이 빈번하여 효율적이지 않음.  
연결리스트로 구현시 이러한 단점을 극복하여 효과적임.  

![image](https://user-images.githubusercontent.com/33312417/231078858-190948d3-4607-48e5-ade2-ad1295a62c66.png)

## ▶ Linked List의 활용: 2. List를 이용한 Stack  
● Stack의 각 원소 = 연결 리스트의 Node  
● Stack의 순서    = 연결 리스트의 Link  

● Stack의 push() = 연결리스트의 맨 앞에 Node를 삽입하는 방식으로 구현  
● Stack의 pop()  =  연결리스트의 맨 앞의 Node를 반환하고 삭제하는 방식으로 구현  
● Stack의 top()  = 연결리스트의 맨 앞 Node를 가리키게되고, 초기 상태는 Node

## ▶ Linked List의 활용: 3. Priority Queue(우선순위 큐)☆★ ● 여기서는 연결 리스트를 활용하여 구현.  

### 순차리스트를 이용한 우선순위 큐  
→ 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조.  
→ 가장 앞에 최고 우선순위의 원소가 위치하게 됨.  
→ **배열을 사용하므로, 삽입 & 삭제시 원소의 재배치로 인해 소요되는 시간이나 메모리 낭비가 큼**  

### 연결리스트를 이용한 우선순위 큐  
→ 원소를 삽입하는 과정에서 Node의 원소들과 비교하여 적절한 위치에 Node를 삽입하는 구조.  
→ 가장 앞에 최고 우선순위의 Node가 위치하게 됨.  
→ **삽입 & 삭제시 원소의 재배치가 필요 없음, 메모리의 효율적인 사용이 가능**  




