# Linked List

## ▶ LIST (리스트)
● **순서를 가진** 데이터의 묶음 = 같은 데이터의 중복 저장 가능.  
● **Sequence 자료형** = Indexing, Slicing, Operator, Method 사용 가능.  
● 크기 제한, 타입 제한 없음.  
● 데이터의 묶음이라는 개념이 타언어의 배열과 흡사함.
  → 배열은 초기에 크기 지정, 변경 불가.  
  → List는 동적 배열의 개념으로, 크기 변경 가능.  
  → 또한, 배열은 선언된 한가지 타입만 저장이 가능하지만 List는 다양한 데이터 타입 저장 가능.  
  → 타언어에서 배열로 구현한 순차 리스트 = Python의 List.  
  → 순차 리스트 : 배열을 기반으로 구현된 리스트.  
  → 연결 리스트 : 메모리의 동적할당을 기반으로 구현된 리스트.  

● 순차 List의 특징  
→ **동적 배열**로 작성된 순차 리스트.  
→ 자료의 삽입/삭제시 **내부적으로는 원소들을 이동** 하는 작업이 필요함.  
→ 때문에 원소의 개수가 많고, 삽입/삭제 연산이 빈번하면 **작업에 소요되는 시간이 크게 증가함.**  

### List의 복사★☆★☆  
● **얕은** 복사, **깊은** 복사가 존재 함.  
● 보통 얕은 복사는 대상과의 **참조한 곳은 동일**하기 때문에 독립적이지 않다.  
● 깊은 복사는 복사 대상과 독립된 객체가 된다.  

● **여러가지 복사 방법들**(밑의 항목일 수록 실행시간이 긺), 방법들 마다 속도 차이가 30배 정도 날 수도 있다.    
  1. `new_list = old_list`   
  2. `new_list = old_list[:]`  
  3. `new_list = []`  
     `new_list.extend(old_list)`  
  4. `new_list = list(old_list)`  
  5. `import copy`  
     `new_list = copy.copy(old_list)`  
  6. `new_list = [k for k in old_list]`  
  7. `import copy`  
     `new_list = copy.deepcopy(old_list)`   
     → **가장 느림, 가장 메모리 소모 큼(하지만 완전한 깊은 복사)**  
  
  ※ 영상에서는 각 방법들마다 얕은, 깊은 복사의 부연 설명까지 되어있으나, 설명이 모호함.
  
  ※ 예를들면, 2번의 경우 깊은 복사라고 해놓았지만 실제 `[:]` 방법은 얕은과 깊은의 혼종 복사이기 때문임. 실제로 내부 원소가 같아지고 참조하는 id()도 달라 깊은 복사 같지만 만약 **List안에 내부 List**가 존재할 경우 그 내부 list는 같은 값을 참조하기 때문에 얕은 복사가 되버림.  
  
  ※ [복사 관련 참고 링크] https://blockdmask.tistory.com/576  
  
## ▶ Linked List (연결 리스트)☆★☆★  
● List의 단점을 보완한 자료 구조.  
● 자료의 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않고, **개별적으로 위치하고 있는 원소의 주소를 연결하여 하나의 전체적인 자료구조**를 이룸.  
● Link를 통해 원소에 접근하므로, 순차 리스트에서 **물리적인 순서를 맞추기 위한 작업이 필요하지 않음.**  
● 자료구조의 크기를 동적으로 조정할 수 있어, **메모리의 효율적인 사용이 가능.**  
● 탐색을 할 때는 **순차 탐색** 활용.  

  
  
  
  
