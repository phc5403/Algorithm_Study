
# 패턴 매칭 알고리즘  


## ▶ 1. Brute_Force(브루트 포스)  
→ 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식.  
→ 최악의 경우 모든 위치에서 패턴을 비교해야 하므로(본문 길이 * 패턴 길이),  
최대 시간 복잡도는 O(N * M).

## ▶ 2. KMP  
→ 불일치가 발생한 문자열의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞부분에 대하여 다시 비교하지않고 다음 매칭을 수행.  

→ 패턴을 전처리하여 배열 nxt[M] (불일치가 발생했을 경우 이동할 다음 위치)을 구해서 자롬ㅅ된 시작을 최소화 하는 방식으로 동작.  

![image](https://user-images.githubusercontent.com/33312417/228741520-096b7ac3-fe43-4078-a290-56d78e7c29e8.png)
→ O(N + M) (=본문 길이 + 패턴 길이)  

![image](https://user-images.githubusercontent.com/33312417/228743864-104e84ab-b10e-4408-891d-db5c2465f3e9.png)
→ (추가 설명)


## ▶ 3. Boyer-Moore(보이어-무어)
→ 대다수의 경우 문자열의 앞부분보다, 끝부분에서 불일치 확률이 높다는 특징에서 착안한 알고리즘.  
끝에서 앞쪽순으로 비교, 대부분의 상용 SW에서 채택하는 알고리즘. 

→ skip[패턴 길이]이라는 배열을 선언 및 활용하여,  
  i) 오른쪽 끝 문자가 불일치 할 때, 패턴 내에 해당 문자가 있음.  
  ii) 오른쪽 끝 문자가 불일치 할 때, 패턴 내에 해당 문자가 없음.  
skip[]은 위와 같은 상황에서 몇 칸을 이동해야하는지 명시 해주는 용도.  
`
패턴 = "abcde"일 때,  
문자 :   a b c d e | 그 외  
인덱스 : 4 3 2 1 0 | len(패턴), 여기서는 5
`
