
# 패턴 매칭 알고리즘  


## ▶ 1. Brute_Force(브루트 포스), O(N * M)  
→ 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식.  

→ 최악의 경우 모든 위치에서 패턴을 비교해야 하므로(본문 길이 * 패턴 길이),  
최대 시간 복잡도는 O(N * M).

## ▶ 2. KMP (Knuth-Morris-Pratt), O(N)  
→ 불일치가 발생한 문자열의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞부분에 대하여 다시 비교하지않고 다음 매칭을 수행.  

→ 패턴을 전처리하여 배열 nxt[M] (불일치가 발생했을 경우 이동할 다음 위치)을 구해서 잘못된 시작을 최소화 하는 방식으로 동작.  

→ O(N + M) (=본문 길이 + 패턴 길이)  

<img src="https://user-images.githubusercontent.com/33312417/228741520-096b7ac3-fe43-4078-a290-56d78e7c29e8.png" width="600" height="175"/>

<img src="https://user-images.githubusercontent.com/33312417/228743864-104e84ab-b10e-4408-891d-db5c2465f3e9.png" width="600" height="200"/>
→ 불일치가 발생했을 때, 돌아갈 곳을 정하기 위해 **접두부, 접미부 경계**개념을 알아야 함.  

→ 이부분은 이해가 어려웠으므로 해당 링크 참조  
**https://chanhuiseok.github.io/posts/algo-14/**



## ▶ 3. Boyer-Moore(보이어-무어), 대개 O(N)보다 작음, 최악 = O(N * M)  
→ 대다수의 경우 문자열의 앞부분보다, 끝부분에서 불일치 확률이 높다는 특징에서 착안한 알고리즘.  
끝에서 앞쪽순으로 비교, 대부분의 상용 SW에서 채택하는 알고리즘. 

→ skip[패턴 길이]이라는 배열을 선언 및 활용하여,  
  i) 오른쪽 끝 문자가 불일치 할 때, 패턴 내에 해당 문자가 있음.  
  ii) 오른쪽 끝 문자가 불일치 할 때, 패턴 내에 해당 문자가 없음.  

skip[]은 위와 같은 상황에서 몇 칸을 이동해야하는지 명시 해주는 용도.  
`패턴 = "abcde"일 때,  `  
`문자 :   a b c d e | 그 외  `  
`인덱스 : 4 3 2 1 0 | len(패턴), 여기서는 5`  
→ 즉, skip[] = 각 문자의 index를 반대로 준 배열.  

![image](https://user-images.githubusercontent.com/33312417/229096740-db934e7b-91c6-4cf3-bc7e-6555e053449d.png)

전체적인 로직의 구성은 다음과 같다.  
  1. 본문과 패턴을 끝에서부터(역순) 검색하여 일치하는지 판단함.   
  2. 일치 한다면, 따로 개수를 카운팅 함.  
  3. 불일치 한다면, 일정한 만큼 Index를 Jump해야하는데 이하 분기에 따라 나뉜다.  
  3-1. 불일치 하지만 본문의 문자가 패턴 내에 **존재할 경우** "jump = skip[i]에 해당하는 수".  
  3-2. 불일치 하고, 본문의 문자가 패턴 내에 **존재하지 않는 경우** "jump = [그외]의 수".   
  4. 본문의 탐색 인덱스를 skip[]에서 나온 "jump - 현재까지 일치한 문자 개수" 만큼 더함.  
  → 4에서 현재까지 일치한 문자 개수 만큼 차감하는 이유는 **패턴속의 문자가 중복될 경우가 있기 때문.**  

## ▶ 3. 카프-로빈(해쉬 기반 탐색 = O(N))    

