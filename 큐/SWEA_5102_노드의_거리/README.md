# PASS, WA 분석

## 1. WA  
● DFS()를 사용했고 Testcase는 모두 맞았으나, 실제 채점에서는 Testcase 10개 중 5개가 Fail.  

● 로직이 맞다고 생각해 반례를 생각하면서, 문제에서 정확한 명시가 없는 "Cycle 간선"을 고려하는지.. 그렇다면 출발, 도착점이 동일 할 때 간선을 0개..? 1개..? 뭘로 간주하는 걸까 등 이것저것 생각해봄.  

● 그러다가 Testcase를 조금 변형하여 출발 - 도착 경로가 2개 이상 존재함을 가정해보니 어떻게 판단해야할까 하다가, 문제에서 "주어진 출발 노드에서 **최소** 몇 개의 간선을 지나면~..."을 보고 내가 또 문제를 100% 이해 못했다는 것을 깨달음.  

● Cycle은 상관이 없었고, 어찌됐든 최소 경로값을 찾기만 하면 됨.  

● WA 후에 BFS()로 변형하여 PASS를 받고나서 큰 로직은 같은데 무슨 차이였을까 뜯어봄.  
  → BFS()의 경우는 QU에서 현재 탐색 할 경로는 제일 앞에 있고, 탐색 예정인 다음 경로들은 제일 뒤에 원소로 들어감.  
  → 다수의 중복 포함 경로 중, 현재 내가 어떤 경로로 특정 노드에 도착했던, visited[] 입장에서는 **먼저 visited[특정 노드]로 도달한 경로가 방문 처리를 해버림.**  
  → 즉 경로 A, B 중 특정 노트 X에 대해 누가 멀리서라도 같은 X를 찍든 말든, **"먼저 도착하여 방문처리 시킨 경로(A or B) == 최소 경로"** 라는 어찌보면 너무 당연한 개념으로 인해 자연스레 최소 경로를 찾게되어 PASS가 됨.  
  ▶ 그렇다면 DFS()는 왜 WA 였을까?  
    → **재귀** 라는 동작 때문에 실행 처리 순서가 주어진 상황에 따라 달라짐으로써, **최소값이 아닌 경로Y가 우연히 먼저 도착하여 방문 처리를 해버려서, 실제 Solution인 경로X가 `if visited[nxt]:` 에서 막혀버리는 case가 발생함!**   
    → 실제 반례를 조작해본 결과  
      `1`  
      `6 6`  
      `1 4`    
      `1 3`  
      `2 3`  
      `2 5`  
      `4 5`  
      `4 6`  
      `2 6`      
      위의 Case에서는 `2 3`이 먼저 입력돼서 3번 노드를 거쳐 멀리 돌아가는 경로로 목적지에 도달하기 때문에 **간선 4개**를 지남.  
      `1`  
      `6 6`  
      `1 4`  
      `1 3`  
      `2 5`  
      `2 3`  
      `4 5`  
      `4 6`  
      `2 6`       
      위의 Case에서는 `2 5`가 먼저 입력되니 원하던 최소 경로인 **간선 3개**를 얻을 수 있음.  
    → 문제의 Testcase는, **반드시 오름차순으로 경로가 주어진다는 등의 보장이 없으므로** 이렇게 WA가 나올 수 있었음.  
