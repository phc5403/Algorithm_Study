# Stack

## ▶ 기본 특징  
● 선형 구조 : 자료 간의 관계가 1대1.  

● 비선형 구조: 자료 간의 관계가 1대N (트리 등).  

● LIFO(Last-In-First-Out, 후입선출)    

● 몇 가지의 기본적인 연산 개념이 존재함.
  top = 스택의 맨 위, 즉 마지막 원소를 가리킴. 없다면 -1.
  push, pop, isEmpty, size, peek(top 위치 참조) 등.  
  
● 스택 구현시 고려사항  
1. List를 사용하여 스택을 구현  
  장점 = 구현 용이  
  단점 = 리스트의 크기를 변경하는 작업은 내부적으로 큰 OverHead를 발생시키는 작업으로, 많은 시간이 소요 됨.  

● 1을 보완하기 위한 방법.    
  a. 리스트의 크기가 변동되지 않도록 배열처럼 크기를 미리 정해놓고 사용하는 방법.  
  b. 동적 연결 리스트를 이용하여 저장소를 동적으로 할당하여 스택을 구현하는 방법.  
→ 장점 = 스택에 삽입 삭제가 빈번할 경우 리스트로 구현한것보단 시간 감소.   
→ 단점 = List로 구현하는 것보다 구현이 복잡함.  

## ▶ 스택의 응용    
### 1. 괄호 검사  
→ PS에서 흔히 나오는 것으로, 대괄호-중괄호-소괄호의 올바른 쌍을 검토하는 경우임.  

→ 보통 괄호의 종류 및 Open-Close의 개수가 같아야 하고, 괄호 사이에는 포함 관계만 존재함.  

### 2. Function Call(함수 호출)  
#### 프로그램에서의 **함수 호출**과 복귀에 따른 **수행 순서를 관리**  
  1. 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 **후입선출 구조**.  
  
  2. 함수 호출이 발생하면 호출한 함수 수행에 필요한 **지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 *스택 프레임*에 저장하여 시스템 스택에 삽입.  
  
  3. 함수의 실행이 끝나면 시스템 Stack의 top 원소(=Stack Frame)를 삭제(pop)하면서 Frame에 저장되어있던 **복귀주소를 확인 후 복귀**  
  
  4. 함수 호출과 복귀에 따라 위 과정을 반복하여 전체 프로그램 수행이 종료되면 시스템 Stack은 공백 Stack이 됨.  

**※ 스택 프레임(Stack Frame):** 함수가 호출될 때, 그 함수만의 스택 영역을 구분하기 위하여 생성되는 공간이다.   
함수 호출 시 할당되며, 함수가 종료되면서 소멸한다.  

● 함수 호출 수행 순서  
![image](https://user-images.githubusercontent.com/33312417/229336098-a2a81dac-6038-430d-b941-b44c41659e91.png)

#### Recursive call(재귀 호출)  
1. 자기 자신을 호출하여 순환 수행되는 작업.  
2. 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀 호출 방식을 사용하여 함수를 만들면 **프로그램의 크기를 줄이고 간단하게 작성**할 수 있음.  
3. **디버깅이 어렵고, 잘못 작성하게 되면 수행 시간이 많이 소요됨.**

● 재귀 호출의 대표적인 예로는 Factorial이 있는데, <b> Stack Frame으로 Stack에 저장되는 값이 입력 값이 틀린 같은 함수의 Stack Frame을 저장한다.</b>는 특징이 있음.  

Ex) Fact(4) 호출 → Stack Frame에는 Fact(4)의 정보가 아닌, Fact(4) **내부에서 호출한 Fact(3)의 정보**가 들어간다는 의미.  

## ▶ Memoization(메모이제이션)★  
→ 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, **이전에 계산한 값을 메모리에 저장함**으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다. **동적 계획법의 핵심**이 되는 기술이다.(위키백과)  

→ 특히 피보나치 수를 구하는 재귀 함수에서, function(N)을 구하기 위해선 많은 중복 호출이 존재 함.
이를 개선하기 위해서 Memoization을 사용.

`memo = [0, 1]`  
`def fibo(N):`  
`if N >= 2 and len(memo) <= N:  # 2번째 조건으로 인해 중복 연산 최소`  
`    memo.append(fibo(N-1) + fibo(N-2))`  
`return memo[n]  # 이미 fibo(N)의 값이 존재하면 바로 반환함으로써 재귀 최소화`  

## ▶ Dynamic Programming(동적 계획법)★★★  
→ Greedy algorithm과 같이 **최적화** 문제를 해결하는 알고리즘.  
→ 본문제를 작은 부분 문제로 나누어 해를 구한 다음, 부분 해를 이용하여 크기가 큰 부분 문제부터 본문제까지를 해결.  

→ 위의 Memoization의 예시에 DP를 적용한 예시.  
`def fibo(n)`
`    DP = [0, 1]`
`    for idx in range(2, n + 1):`  
`        DP.append(DP[idx-1] + DP[idx-2])`
`    return DP[n]`  

● DP의 구현 방식 비교  
1. Recursive 방식
  → 재귀적 구조는 내부에 시스템 호출 스택을 사용하는 OverHead가 발생할 수 있음.  

2. Iterative 방식  
  → Memoization을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현한 것이 **성능 면에서 보다 효율적**  
  
## ▶ DFS(깊이 우선 탐색)★★★  
● 비선형구조인 Graph는 표현된 모든 자료를 검색하는 것이 중요함.  
  1. DFS(Depth-First-Search)
  2. BFS(Breadth-First-Search)
  
## ▶ Stack의 활용 - 계산기★★ 
### 문자열 수식 계산의 일반적 방법.  
● Infix notation(중위표기법) → Postfix notation(후위표기법)으로 변환하여 Stack을 이용하여 계산.  

● Infix → Postfix 변환하는 방법  
  0. 각 연산자별 우선순위를 저장하는 List 만듦.  
  1. 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현.  
  2. 각 연산자를 그에 대응하는 오른쪽 괄호의 뒤로 이동.  
  3. 괄호 제거  

Ex) "A * B - C / D"  
`1. ( (A * B) - (C / D) )`  
`2. ( (AB) * (CD)/ )-`  
`3. AB*CD/-`  

### Stack을 활용하여 Infix → Postfix를 구현★★
# Stack2 - 01:계산기 영상 참조
#### 1. 변환  

icp(in-coming-priority) 스택에 들어오는 경우의 연산자 우선순위 
isp(in-stack-priority) 스택내부에서의 연산자 우선순위
if icp > isp: push()
else pop()

토큰   ISP  ICP
)      -     -  
*, /   2     2 
+, -   1     1 
(      0     3
→ 숫자가 클 수록 우선순위가 높음.  

#### 2. 만들어진 Postfix 계산  
→ 영상 과정이 긺  
→ 직접 코딩해서 구하고 과정을 여기 다시 적는게 나을듯  
(어처피 영상에서는 직접 구현안하고 내장함수 eva()쓰는거임)  

## ▶ Back-tracking(백트래킹)★★★   
# Stack2 - 02:백트래킹 영상 참조  
**→ 해를 찾는 도중에 막히면 "되돌아가서" 다시 해를 찾아가는 기법.**  

### ● 특징  
1. 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 **시도의 횟수를 줄임**  
2. 불필요한 경로의 조기 차단으로 인해 **Prunning**(가지치기)개념을 기반으로 함(즉, 모든 후보를 검사하지 않음).  

3. N!(지수함수 등) 가지의 경우의 수를 가진 문제에 대해 Back-tracking을 적용하면 일반적으로 **경우의 수가 줄어들지만**,  
**최악의 경우에는 여전히 Exponential Time(지수함수 시간)이 걸리므로 처리 하기 적합하지 않음.**  

4. DFS의 경우는 3과 같은 상황에서 모든 경로 및 후보를 검사하기 때문에 일반적으로 Exponential Time의 문제를 처리하기에 적합하지 않음.  
  
5. 어떤 노드의 유망성을 점검한 후에 Promising(유망)하지 않다고 결정되면 → 그 노드의 부모로 되돌아가(Back-tracking) 다음 자식 노드로 감.  
이러한 Pruning를 통해 해답의 가능성이 있는 Promising을 추적해 나감.  

● 적용 가능한 PS  
1. Optimization(최적화)  
2. Decision(결정): 문제의 조건을 만족하는 해가 존재하는지 여부에 따라 True, False로 나타나는 문제.
  **미로 찾기 / n-Queen / Map_coloring / Power-Set: 부분 집합의 합(Subset Sum) 등이 있음.**  
  
※ n-Queen: N * N의 정사각형 안에 N개의 queen을 배치하는 문제로, **모든 queen은 자신의 일직선상(가로, 세로) 및 대각선상에 아무 것도 놓이지 않아야 함.**  

※ Power-Set: 어떤 집합의 공집합과 자기자신을 포함한 모든 부분 집합.  
구하고자 하는 어떤 집합의 원소 개수가 n일 경우 부분집합의 개수 = 2^n.  

ㅇ백트래킹 기법으로 파워셋 구하기 08:00 ~ 
1. 일반적인 백트래킹 접근 방법 이용.  
2. n개의 원소가 들어있는 집합의 2^n개의 부분집합을 만들 때, True-False 값을 가지는 항목들로 구성된 n개의 리스트를 만드는 방법 이용.  
3. 리스트의 i번째 항목은 i번째의 원소가 부분집합의 값인지 아닌지를 나타내는 값.  

=> 이거 약간 재귀로 bit[] 만들어서 1, 0 체크 반복해서 모든 부분집합 구하는 코드랑 유사함.  

![image](https://user-images.githubusercontent.com/33312417/229347000-702eab8a-04c5-4e4e-8d93-334ed6a243ae.png)

ㅇ백트래킹 기법으로 순열 구하기 14:30 ~ 
![image](https://user-images.githubusercontent.com/33312417/229347094-eba749c7-2463-45d5-95a7-ec71bdbc3612.png)

![image](https://user-images.githubusercontent.com/33312417/229347264-f07cd1cc-4f51-4ec3-88a8-4d9e147aeff1.png)

=> 이것도 그냥 다른 순열 구현 코드를 보고 이해하는게 더 나을지도..  


## ▶ Divide and Conquer(분할 정복)  
1. DIvede(분할): 해결할 문제를 **여러 개의 작은 부분**으로 나눔.  
2. COnquer(정복): 나눈 작은 문제를 **각각 해결**  

3. Combine(통합): (필요하다면) 해결된 **해답을 모음**  

● 일반적으로 Exponentiation(거듭 제곱)을 구할 때,  
구하려는 N승만큼의 반복문을 통해 계속 곱해나가므로 **O(N)**이 걸림.  하지만 분할 정복으로는  
![image](https://user-images.githubusercontent.com/33312417/229695970-09d55330-afd9-4ce5-8e95-05b6e9810961.png)

위와 같은 과정을 통해 **O(log2N)**이 걸림.  

● 합병 정렬과 퀵 정렬의 비교  
![image](https://user-images.githubusercontent.com/33312417/229696749-2dabb9fb-e341-4e32-bea7-70e28808273f.png)  


![image](https://user-images.githubusercontent.com/33312417/229698951-0af0c16f-42f3-4e69-bbb0-d7dbe501bffa.png)
→ 퀵 정렬은 최악의 경우 합병에 비해 효율이 떨어지지만, 평균 복잡도는 O(NlogN)이므로 가장 빠르다.  




