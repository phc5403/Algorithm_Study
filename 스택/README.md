# Stack

## ▶ 기본 특징  
● 선형 구조 : 자료 간의 관계가 1대1.  

● 비선형 구조: 자료 간의 관계가 1대N (트리 등).  

● LIFO(Last-In-First-Out, 후입선출)    

● 몇 가지의 기본적인 연산 개념이 존재함.
  top = 스택의 맨 위, 즉 마지막 원소를 가리킴. 없다면 -1.
  push, pop, isEmpty, size, peek(top 위치 참조) 등.  
  
● 스택 구현시 고려사항  
1. List를 사용하여 스택을 구현  
  장점 = 구현 용이  
  단점 = 리스트의 크기를 변경하는 작업은 내부적으로 큰 OverHead를 발생시키는 작업으로, 많은 시간이 소요 됨.  

● 1을 보완하기 위한 방법.    
  a. 리스트의 크기가 변동되지 않도록 배열처럼 크기를 미리 정해놓고 사용하는 방법.  
  b. 동적 연결 리스트를 이용하여 저장소를 동적으로 할당하여 스택을 구현하는 방법.  
→ 장점 = 스택에 삽입 삭제가 빈번할 경우 리스트로 구현한것보단 시간 감소.   
→ 단점 = List로 구현하는 것보다 구현이 복잡함.  

## ▶ 스택의 응용    
### 1. 괄호 검사  
→ PS에서 흔히 나오는 것으로, 대괄호-중괄호-소괄호의 올바른 쌍을 검토하는 경우임.  

→ 보통 괄호의 종류 및 Open-Close의 개수가 같아야 하고, 괄호 사이에는 포함 관계만 존재함.  

### 2. Function Call(함수 호출)  
#### 프로그램에서의 **함수 호출**과 복귀에 따른 **수행 순서를 관리**  
  1. 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 **후입선출 구조**.  
  
  2. 함수 호출이 발생하면 호출한 함수 수행에 필요한 **지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 *스택 프레임*에 저장하여 시스템 스택에 삽입.  
  
  3. 함수의 실행이 끝나면 시스템 Stack의 top 원소(=Stack Frame)를 삭제(pop)하면서 Frame에 저장되어있던 **복귀주소를 확인 후 복귀**  
  
  4. 함수 호출과 복귀에 따라 위 과정을 반복하여 전체 프로그램 수행이 종료되면 시스템 Stack은 공백 Stack이 됨.  

**※ 스택 프레임(Stack Frame):** 함수가 호출될 때, 그 함수만의 스택 영역을 구분하기 위하여 생성되는 공간이다.   
함수 호출 시 할당되며, 함수가 종료되면서 소멸한다.  

● 함수 호출 수행 순서  
![image](https://user-images.githubusercontent.com/33312417/229336098-a2a81dac-6038-430d-b941-b44c41659e91.png)

#### Recursive call(재귀 호출)  
1. 자기 자신을 호출하여 순환 수행되는 작업.  
2. 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀 호출 방식을 사용하여 함수를 만들면 **프로그램의 크기를 줄이고 간단하게 작성**할 수 있음.  
3. **디버깅이 어렵고, 잘못 작성하게 되면 수행 시간이 많이 소요됨.**

● 재귀 호출의 대표적인 예로는 Factorial이 있는데,  
**Stack Frame으로 Stack에 저장되는 값이 입력 값이 틀린 같은 함수의 Stack Frame을 저장한다.**는 특징이 있음.  

Ex) Fact(4) 호출 → Stack Frame에는 Fact(4)의 정보가 아닌, Fact(4) **내부에서 호출한 Fact(3)의 정보**가 들어간다는 의미.  

## ▶ Memoization(메모이제이션)★  
→ 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, **이전에 계산한 값을 메모리에 저장함**으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다. **동적 계획법의 핵심**이 되는 기술이다.(위키백과)  

→ 특히 피보나치 수를 구하는 재귀 함수에서, function(N)을 구하기 위해선 많은 중복 호출이 존재 함.
이를 개선하기 위해서 Memoization을 사용.

`memo = [0, 1]`  
`def fibo(N):`  
`if N >= 2 and len(memo) <= N:  # 2번째 조건으로 인해 중복 연산 최소`  
`    memo.append(fibo(N-1) + fibo(N-2))`  
`return memo[n]  # 이미 fibo(N)의 값이 존재하면 바로 반환함으로써 재귀 최소화`  

## ▶ Dynamic Programming(동적 계획법)★★★  
→ Greedy algorithm과 같이 **최적화** 문제를 해결하는 알고리즘.  
→ 본문제를 작은 부분 문제로 나누어 해를 구한 다음, 부분 해를 이용하여 크기가 큰 부분 문제부터 본문제까지를 해결.  

→ 위의 Memoization의 예시에 DP를 적용한 예시.  
`def fibo(n)`
`    DP = [0, 1]`
`    for idx in range(2, n + 1):`  
`        DP.append(DP[idx-1] + DP[idx-2])`
`    return DP[n]`  

● DP의 구현 방식 비교  
1. Recursive 방식
  → 재귀적 구조는 내부에 시스템 호출 스택을 사용하는 OverHead가 발생할 수 있음.  

2. Iterative 방식  
  → Memoization을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현한 것이 **성능 면에서 보다 효율적**  
  
## ▶ DFS(깊이 우선 탐색)★★★  
● 비선형구조인 Graph는 표현된 모든 자료를 검색하는 것이 중요함.  
  1. DFS(Depth-First-Search)
  2. BFS(Breadth-First-Search)
  
