# 정리
● Testcase 10개, C/C++ = 1 sec, Java = 2 sec, 256 MB
→ SWEA는 항상 문제 메인화면에선 Python의 Time Limit이 명시되지 않아 불편했는데, 잘 찾아보니 "문제 풀기"로 진입시에 따로 명시가 돼있었다.  
하지만 백준과 다르게 Java와 같은 2 sec라서 TLE가 4번이나 뜨는 불상사가 있었으나, 그냥 PyPy를 선택한 이유로 감수해야 할 것같다.  

→ 처음 두 세번은 BFS + DFS + visited[][] 등을 사용하면서 어찌어찌 무겁게 짜긴해봤으나, TLE에 부딪혔다.  
→ 이후 nQueen 문제의 알고리즘을 구글링하면서 어떻게 동작해야하는지 감을 잡은 후 다시 풀어보았다.  
→ 이 문제의 핵심은 효율적 + TLE 방지를위해 visited를 <b>"1차원 List"</b>로 설정해야 하는것인데,  
<b>"Index = 행, visited[idx] = 열"</b>이라는 발상으로 해결할 수 있었으나, 처음엔 떠올리지 못하고 구글링을 통해 새롭게 알게되었다.  
→ 해당 문제 파일마다 주석으로 로직을 설명해놓았음.  

## 1. TLE_1.py
● 처음에 방문 List q를 []로 시작함.  
1. n_queens(행, 방문 배열):  
  a. 함수 초입에서 행이 N의 범위까지 갔다면, 모두 확인한것이니 for-q[] 순회하면서 실제 List값을 누적하고, res 최솟값 갱신.  
  b. 0 ~ N까지 반복하면서 pruning()으로 Promising 판단.  
  c. Promising하다면, q[]에 위치를 추가.  
  d. 다음 위치를 위해 n_queens(행 + 1, q[])로 재귀 호출.
  e. 다음 행에 놓기 위해 이전에 추가했던 위치를 pop().  
    
2. pruning(q[], col):
  a. List가 비어있다면, 처음 위치이므로 바로 True 반환.  
  b. 방문 위치가 저장되어있는 q[] 내부를 순회하면서 현재 col이 놓일 수 있는지 여부를 return.  
  
## 2. TLE_2.py
● TLE_1.py에서 방문 배열을 수시로 append(), pop()하는 과정에서 시간이 많이 소모된다고 판단.  
→ 방문 배열을 처음부터 N의 개수만큼 0으로 채우고 비트 마스킹으로 0, 1값만 주어 갈 수 있는지 판단.  
→ Promising을 판단하는 함수를 없애고, 단순히 queen[col]이 0 or 1인지만 확인 하면 됨.

● n_queens()에서 종료 할 때 마다 for-q[] 순회하는 시간을 없애기 위해 누적합을 매개변수로 추가하여 들고다니다가 종료 할 때 간단하게 min()으로 비교.  

● 하지만 위처럼 리팩토링을 했음에도, 유의미한 시간 차이는 없었고 여전히 4000ms가 나와서 TLE.  

## 3. PASS.py
● 줄일 수 있는 연산을 최소화 하고자 생각하던 중 아예 종료 조건을 하나 더 추가해 n_queens()를 재귀 호출 해나가는 도중에  
<b>"현재까지 계산된 누적합 > 결과에 쓰일 최솟값(res)"</b>인 경우 굳이 끝까지 계산 할 필요없이 정답 후보에서 제외되므로 이 경우 함수를 종료시킴.  

● 결국 위의 수정으로 인해, 주어진 N의 최대범위로 만든 자체 반례에서 600ms대가 나오면서 겨우 PASS.  

● 아마 백준처럼 언어별 시간 보너스가 있었다면 이전의 실패했던 코드도 PASS였을수도 있었겠지만,  
어쨌든 PS를 하는 입장에서는 코드나 로직이 빠르고 가벼울수록 좋고, 주어진 2sec로 풀지 못하는 경우도 아니었기 때문에 결국은 내가 잘하면 된다고 생각됨.   
